//
//  JAKeyTranslator.m
//  KeyFromQWERTY
//
//  Created by Jens Ayton on 2008-09-13.
//  Copyright 2008 Jens Ayton. All rights reserved.
//

#import "JAKeyTranslator.h"
#import <Carbon/Carbon.h>


enum
{
	kBufferSize = 128	// Maximum number of characters that can be generated by one call.
};

@interface JAKeyTranslator (Private)

- (NSString *) translatedKeyForVKCSequenceUchr:(uint16_t *)vkcs count:(NSUInteger)count;

// 64-bit support is incomplete; the KeyboardLayout stuff needs to be replaced with TISInputSources.
#ifndef __LP64__
- (NSString *) translatedKeyForVKCSequenceKCHR:(uint16_t *)vkcs count:(NSUInteger)count;
#endif

@end


@implementation JAKeyTranslator

+ (id) keyTranslatorForCurrentKeyboardLayout
{
	KeyboardLayoutRef		layout;
	
	if (KLGetCurrentKeyboardLayout(&layout) != noErr)  return nil;
	return [[[self alloc] initWithKeyboardLayout:layout] autorelease];
}


- (id) initWithKeyboardLayout:(struct OpaqueKeyboardLayoutRef *)layout
{
	OSStatus				err;
	
	if ((self = [super init]))
	{
		// Get keyboard layout name
		err = KLGetKeyboardLayoutProperty(layout, kKLName, (const void **)&_name);
		if (_name == nil)  _name = [NSString stringWithFormat:@"<error %i getting name>", err];
		[_name retain];
		
		// Get keyboard layout language code
		err = KLGetKeyboardLayoutProperty(layout, kKLLanguageCode, (const void **)&_langCode);
		[_langCode retain];
		// Langauge code may be nil.
		
		// Get keyboard layout identifier
		err = KLGetKeyboardLayoutProperty(layout, kKLIdentifier, (const void **)&_identifier);
		if (err == noErr)  _hasIdentifier = YES;
		
		// Attempt to get 'uchr' data for UCKeyTranslate().
		err = KLGetKeyboardLayoutProperty(layout, kKLuchrData, (const void **)&_translateData);
		if (err == noErr)
		{
#ifndef __LP64__
			_isUchr = YES;
#endif
		}
		else
		{
#ifndef __LP64__
			// No 'uchr' data, try getting 'KCHR' data for KeyTranslate().
			err = KLGetKeyboardLayoutProperty(layout, kKLKCHRData, (const void **)&_translateData);
#endif
			if (err != noErr)
			{
				[self release];
				return nil;
			}
		}
		
		_layout = layout;
	}
	
	return self;
}


- (void) dealloc
{
	[_name release];
	[_langCode release];
	
	[super dealloc];
}


- (NSString *) description
{
	return [NSString stringWithFormat:@"<%@ %p>{\"%@\"}", self.className, self, self.layoutName];
}


- (NSString *) translatedKeyForVKCSequence:(uint16_t *)vkcs count:(NSUInteger)count
{
	
#ifndef __LP64__
	if (_isUchr)  return [self translatedKeyForVKCSequenceUchr:vkcs count:count];
	else  return [self translatedKeyForVKCSequenceKCHR:vkcs count:count];
#else
	return [self translatedKeyForVKCSequenceUchr:vkcs count:count];
#endif
}


- (NSString *) translatedKeyForVKCSequenceUchr:(uint16_t *)vkcs count:(NSUInteger)count
{
	OSStatus				err;
	NSUInteger				i;
	UInt32					state = 0;
	UniCharCount			actualLength, totalLength = 0;
	OptionBits				options = 0;
	UniChar					ucBuffer[kBufferSize];
	
	for (i = 0; i < count; i++)
	{
		if (i == count - 1)  options = kUCKeyTranslateNoDeadKeysMask;
		err = UCKeyTranslate(_translateData, vkcs[i], kUCKeyActionDisplay, 0, LMGetKbdType(), options, &state, kBufferSize - totalLength, &actualLength, ucBuffer + totalLength);
		if (err != noErr)  return nil;
		totalLength += actualLength;
	}
	
	return [NSString stringWithCharacters:ucBuffer length:actualLength];
}


#ifndef __LP64__
- (NSString *) translatedKeyForVKCSequenceKCHR:(uint16_t *)vkcs count:(NSUInteger)count
{
	OSStatus				err;
	NSUInteger				i;
	UInt32					state = 0;
	unsigned				value;
	NSUInteger				length;
	char					buffer[kBufferSize];
	unichar					ucBuffer[kBufferSize];
	ScriptCode				script;
	TextEncoding			encoding = -1;
	TECObjectRef			converter = NULL;
	ByteCount				actualInputLength, actualOutputLength;
	
	for (i = 0; i < count; i++)
	{
		value = KeyTranslate(_translateData, vkcs[i], &state);
		if (value != 0 && length < kBufferSize)
		{
			buffer[length++] = value;
		}
	}
	
	// Translate happy fun Script Manager encoding to something NSStringable
	script = GetScriptManagerVariable(smKeyScript);
	TextEncoding enc = -1;
	
	err = UpgradeScriptInfoToTextEncoding(script, kTextLanguageDontCare, kTextRegionDontCare, NULL, &encoding);
	if (err == noErr)  err = TECCreateConverter(&converter, enc, kTextEncodingUnicodeV5_0);
	
	if (err == noErr)
	{
		err = TECConvertText(converter, (ConstTextPtr)buffer, length, &actualInputLength, (TextPtr)ucBuffer, kBufferSize, &actualOutputLength);
		TECDisposeConverter(converter);
	}
	
	if (err == noErr)  return [NSString stringWithCharacters:ucBuffer length:actualOutputLength];
	else  return nil;
}
#endif


- (NSString *) translatedKeyForVKCSequence:(NSArray *)vkcsAsNumbers
{
	uint16_t				*array = NULL;
	NSUInteger				i, count;
	NSString				*result = nil;
	
	if (vkcsAsNumbers == nil)  return nil;
	
	count = vkcsAsNumbers.count;
	array = malloc(sizeof *array * count);
	if (array == NULL)  return nil;
	
	@try
	{
		for (i = 0; i != count; i++)
		{
			array[i] = [[vkcsAsNumbers objectAtIndex:i] intValue];
		}
		result = [self translatedKeyForVKCSequence:array count:count];
	}
	@finally
	{
		free(array);
	}
	return result;
}


- (NSString *) translatedKeyForVKC:(uint16_t)vkc
{
	return [self translatedKeyForVKCSequence:&vkc count:1];
}


- (NSString *) layoutName
{
	return _name;
}


- (NSString *) layoutLanguageCode
{
	return _langCode;
}


- (NSNumber *) layoutIdentifier
{
	if (_hasIdentifier)  return [NSNumber numberWithInt:_identifier];
	else  return nil;
}

@end
